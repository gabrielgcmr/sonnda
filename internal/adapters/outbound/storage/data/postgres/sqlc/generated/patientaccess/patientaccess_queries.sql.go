// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: patientaccess_queries.sql

package patientaccesssqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAccessiblePatientsByUser = `-- name: CountAccessiblePatientsByUser :one
SELECT COUNT(*) AS total
FROM patient_access pa
JOIN patients p ON p.id = pa.patient_id
WHERE pa.grantee_id = $1
  AND pa.revoked_at IS NULL
  AND p.deleted_at IS NULL
`

// Total count for pagination of accessible patients by user
func (q *Queries) CountAccessiblePatientsByUser(ctx context.Context, granteeID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAccessiblePatientsByUser, granteeID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const findPatientAccess = `-- name: FindPatientAccess :one
SELECT
    patient_id,
    grantee_id,
    relation_type,
    created_at,
    revoked_at,
    granted_by
FROM patient_access
WHERE patient_id = $1
  AND grantee_id = $2
`

type FindPatientAccessParams struct {
	PatientID pgtype.UUID `json:"patient_id"`
	GranteeID pgtype.UUID `json:"grantee_id"`
}

func (q *Queries) FindPatientAccess(ctx context.Context, arg FindPatientAccessParams) (PatientAccess, error) {
	row := q.db.QueryRow(ctx, findPatientAccess, arg.PatientID, arg.GranteeID)
	var i PatientAccess
	err := row.Scan(
		&i.PatientID,
		&i.GranteeID,
		&i.RelationType,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.GrantedBy,
	)
	return i, err
}

const listAccessiblePatientsByUser = `-- name: ListAccessiblePatientsByUser :many
SELECT
    pa.patient_id,
    p.full_name,
    p.avatar_url,
    pa.relation_type
FROM patient_access pa
JOIN patients p ON p.id = pa.patient_id
WHERE pa.grantee_id = $1
  AND pa.revoked_at IS NULL
  AND p.deleted_at IS NULL
ORDER BY p.full_name
LIMIT $2 OFFSET $3
`

type ListAccessiblePatientsByUserParams struct {
	GranteeID pgtype.UUID `json:"grantee_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type ListAccessiblePatientsByUserRow struct {
	PatientID    pgtype.UUID `json:"patient_id"`
	FullName     string      `json:"full_name"`
	AvatarUrl    pgtype.Text `json:"avatar_url"`
	RelationType string      `json:"relation_type"`
}

// Minimal list of patients accessible by a user (for UI listing)
// Returns patient basic info and the relation type. Paginates by full_name.
func (q *Queries) ListAccessiblePatientsByUser(ctx context.Context, arg ListAccessiblePatientsByUserParams) ([]ListAccessiblePatientsByUserRow, error) {
	rows, err := q.db.Query(ctx, listAccessiblePatientsByUser, arg.GranteeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccessiblePatientsByUserRow
	for rows.Next() {
		var i ListAccessiblePatientsByUserRow
		if err := rows.Scan(
			&i.PatientID,
			&i.FullName,
			&i.AvatarUrl,
			&i.RelationType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatientAccessByPatient = `-- name: ListPatientAccessByPatient :many
SELECT
    patient_id,
    grantee_id,
    relation_type,
    created_at,
    revoked_at,
    granted_by
FROM patient_access
WHERE patient_id = $1
ORDER BY grantee_id
`

func (q *Queries) ListPatientAccessByPatient(ctx context.Context, patientID pgtype.UUID) ([]PatientAccess, error) {
	rows, err := q.db.Query(ctx, listPatientAccessByPatient, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PatientAccess
	for rows.Next() {
		var i PatientAccess
		if err := rows.Scan(
			&i.PatientID,
			&i.GranteeID,
			&i.RelationType,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.GrantedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatientAccessByUser = `-- name: ListPatientAccessByUser :many
SELECT
    patient_id,
    grantee_id,
    relation_type,
    created_at,
    revoked_at,
    granted_by
FROM patient_access
WHERE grantee_id = $1
ORDER BY patient_id
`

func (q *Queries) ListPatientAccessByUser(ctx context.Context, granteeID pgtype.UUID) ([]PatientAccess, error) {
	rows, err := q.db.Query(ctx, listPatientAccessByUser, granteeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PatientAccess
	for rows.Next() {
		var i PatientAccess
		if err := rows.Scan(
			&i.PatientID,
			&i.GranteeID,
			&i.RelationType,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.GrantedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokePatientAccess = `-- name: RevokePatientAccess :execrows
UPDATE patient_access
SET revoked_at = now()
WHERE patient_id = $1
  AND grantee_id = $2
  AND revoked_at IS NULL
`

type RevokePatientAccessParams struct {
	PatientID pgtype.UUID `json:"patient_id"`
	GranteeID pgtype.UUID `json:"grantee_id"`
}

func (q *Queries) RevokePatientAccess(ctx context.Context, arg RevokePatientAccessParams) (int64, error) {
	result, err := q.db.Exec(ctx, revokePatientAccess, arg.PatientID, arg.GranteeID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertPatientAccess = `-- name: UpsertPatientAccess :exec

INSERT INTO patient_access (
    patient_id,
    grantee_id,
    relation_type,
    granted_by
) VALUES ($1, $2, $3, $4)
ON CONFLICT (patient_id, grantee_id)
DO UPDATE SET
    relation_type = EXCLUDED.relation_type,
    granted_by = EXCLUDED.granted_by,
    revoked_at = NULL
`

type UpsertPatientAccessParams struct {
	PatientID    pgtype.UUID `json:"patient_id"`
	GranteeID    pgtype.UUID `json:"grantee_id"`
	RelationType string      `json:"relation_type"`
	GrantedBy    pgtype.UUID `json:"granted_by"`
}

// internal/adapters/outbound/database/sqlc/patientaccess/queries.sql
func (q *Queries) UpsertPatientAccess(ctx context.Context, arg UpsertPatientAccessParams) error {
	_, err := q.db.Exec(ctx, upsertPatientAccess,
		arg.PatientID,
		arg.GranteeID,
		arg.RelationType,
		arg.GrantedBy,
	)
	return err
}
