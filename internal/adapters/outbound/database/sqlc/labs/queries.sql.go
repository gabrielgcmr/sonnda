// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package labssqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLabReport = `-- name: CreateLabReport :one


INSERT INTO lab_reports (
    patient_id,
    patient_name,
    patient_dob,
    lab_name,
    lab_phone,
    insurance_provider,
    requesting_doctor,
    technical_manager,
    report_date,
    raw_text,
    uploaded_by_user_id,
    fingerprint
)
VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11, $12
)
RETURNING
    id,
    patient_id,
    patient_name,
    patient_dob,
    lab_name,
    lab_phone,
    insurance_provider,
    requesting_doctor,
    technical_manager,
    report_date,
    raw_text,
    uploaded_by_user_id,
    fingerprint,
    created_at,
    updated_at
`

type CreateLabReportParams struct {
	PatientID         pgtype.UUID `json:"patient_id"`
	PatientName       pgtype.Text `json:"patient_name"`
	PatientDob        pgtype.Date `json:"patient_dob"`
	LabName           pgtype.Text `json:"lab_name"`
	LabPhone          pgtype.Text `json:"lab_phone"`
	InsuranceProvider pgtype.Text `json:"insurance_provider"`
	RequestingDoctor  pgtype.Text `json:"requesting_doctor"`
	TechnicalManager  pgtype.Text `json:"technical_manager"`
	ReportDate        pgtype.Date `json:"report_date"`
	RawText           pgtype.Text `json:"raw_text"`
	UploadedByUserID  pgtype.UUID `json:"uploaded_by_user_id"`
	Fingerprint       pgtype.Text `json:"fingerprint"`
}

// internal/adapters/outbound/database/sqlc/labs/queries.sql
// ============================================================
// Creators
// ============================================================
func (q *Queries) CreateLabReport(ctx context.Context, arg CreateLabReportParams) (LabReport, error) {
	row := q.db.QueryRow(ctx, createLabReport,
		arg.PatientID,
		arg.PatientName,
		arg.PatientDob,
		arg.LabName,
		arg.LabPhone,
		arg.InsuranceProvider,
		arg.RequestingDoctor,
		arg.TechnicalManager,
		arg.ReportDate,
		arg.RawText,
		arg.UploadedByUserID,
		arg.Fingerprint,
	)
	var i LabReport
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.PatientName,
		&i.PatientDob,
		&i.LabName,
		&i.LabPhone,
		&i.InsuranceProvider,
		&i.RequestingDoctor,
		&i.TechnicalManager,
		&i.ReportDate,
		&i.RawText,
		&i.UploadedByUserID,
		&i.Fingerprint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLabResult = `-- name: CreateLabResult :one
INSERT INTO lab_results(
    lab_report_id,
    test_name,
    material,
    method,
    collected_at,
    release_at
)
VALUES ($1,$2,$3,$4,$5,$6)
RETURNING id
`

type CreateLabResultParams struct {
	LabReportID pgtype.UUID        `json:"lab_report_id"`
	TestName    string             `json:"test_name"`
	Material    pgtype.Text        `json:"material"`
	Method      pgtype.Text        `json:"method"`
	CollectedAt pgtype.Timestamptz `json:"collected_at"`
	ReleaseAt   pgtype.Timestamptz `json:"release_at"`
}

func (q *Queries) CreateLabResult(ctx context.Context, arg CreateLabResultParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createLabResult,
		arg.LabReportID,
		arg.TestName,
		arg.Material,
		arg.Method,
		arg.CollectedAt,
		arg.ReleaseAt,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createLabResultItem = `-- name: CreateLabResultItem :one
INSERT INTO lab_result_items (
    lab_result_id,
    parameter_name,
    result_value,
    result_unit,
    reference_text
)
VALUES ($1,$2,$3,$4,$5)
RETURNING id
`

type CreateLabResultItemParams struct {
	LabResultID   pgtype.UUID `json:"lab_result_id"`
	ParameterName string      `json:"parameter_name"`
	ResultValue   pgtype.Text `json:"result_value"`
	ResultUnit    pgtype.Text `json:"result_unit"`
	ReferenceText pgtype.Text `json:"reference_text"`
}

func (q *Queries) CreateLabResultItem(ctx context.Context, arg CreateLabResultItemParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createLabResultItem,
		arg.LabResultID,
		arg.ParameterName,
		arg.ResultValue,
		arg.ResultUnit,
		arg.ReferenceText,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteLabReport = `-- name: DeleteLabReport :execrows
DELETE FROM lab_reports
WHERE id = $1
`

func (q *Queries) DeleteLabReport(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteLabReport, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteLabResultItemsByReportID = `-- name: DeleteLabResultItemsByReportID :execrows

DELETE FROM lab_result_items
WHERE lab_result_id IN (
  SELECT id FROM lab_results WHERE lab_report_id = $1
)
`

// ============================================================
// Deletes
// ============================================================
func (q *Queries) DeleteLabResultItemsByReportID(ctx context.Context, labReportID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteLabResultItemsByReportID, labReportID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteLabResultsByReportID = `-- name: DeleteLabResultsByReportID :execrows
DELETE FROM lab_results
WHERE lab_report_id = $1
`

func (q *Queries) DeleteLabResultsByReportID(ctx context.Context, labReportID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteLabResultsByReportID, labReportID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const existsLabReportByPatientAndFingerprint = `-- name: ExistsLabReportByPatientAndFingerprint :one

SELECT EXISTS(
  SELECT 1
  FROM lab_reports
  WHERE patient_id  = $1
    AND fingerprint = $2
)
`

type ExistsLabReportByPatientAndFingerprintParams struct {
	PatientID   pgtype.UUID `json:"patient_id"`
	Fingerprint pgtype.Text `json:"fingerprint"`
}

// ============================================================
// Dedupe (Existence checks)
// ============================================================
func (q *Queries) ExistsLabReportByPatientAndFingerprint(ctx context.Context, arg ExistsLabReportByPatientAndFingerprintParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsLabReportByPatientAndFingerprint, arg.PatientID, arg.Fingerprint)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getLabReportByID = `-- name: GetLabReportByID :one

SELECT
    id,
    patient_id,
    patient_name,
    patient_dob,
    lab_name,
    lab_phone,
    insurance_provider,
    requesting_doctor,
    technical_manager,
    report_date,
    raw_text,
    uploaded_by_user_id,
    fingerprint,
    created_at,
    updated_at
FROM lab_reports
WHERE id = $1
`

// ============================================================
// Getters
// ============================================================
func (q *Queries) GetLabReportByID(ctx context.Context, id pgtype.UUID) (LabReport, error) {
	row := q.db.QueryRow(ctx, getLabReportByID, id)
	var i LabReport
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.PatientName,
		&i.PatientDob,
		&i.LabName,
		&i.LabPhone,
		&i.InsuranceProvider,
		&i.RequestingDoctor,
		&i.TechnicalManager,
		&i.ReportDate,
		&i.RawText,
		&i.UploadedByUserID,
		&i.Fingerprint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLabResultsByReportID = `-- name: GetLabResultsByReportID :one
SELECT
    id,
    test_name,
    material,
    method,
    collected_at,
    release_at
FROM lab_results
WHERE lab_report_id = $1
ORDER BY test_name
`

type GetLabResultsByReportIDRow struct {
	ID          pgtype.UUID        `json:"id"`
	TestName    string             `json:"test_name"`
	Material    pgtype.Text        `json:"material"`
	Method      pgtype.Text        `json:"method"`
	CollectedAt pgtype.Timestamptz `json:"collected_at"`
	ReleaseAt   pgtype.Timestamptz `json:"release_at"`
}

func (q *Queries) GetLabResultsByReportID(ctx context.Context, labReportID pgtype.UUID) (GetLabResultsByReportIDRow, error) {
	row := q.db.QueryRow(ctx, getLabResultsByReportID, labReportID)
	var i GetLabResultsByReportIDRow
	err := row.Scan(
		&i.ID,
		&i.TestName,
		&i.Material,
		&i.Method,
		&i.CollectedAt,
		&i.ReleaseAt,
	)
	return i, err
}

const listLabItemTimelineByPatientAndParameter = `-- name: ListLabItemTimelineByPatientAndParameter :many

SELECT
  lr.id           AS report_id,
  r.id          AS lab_result_id,
  i.id          AS item_id,
  lr.report_date  AS report_date,
  r.test_name   AS test_name,
  i.parameter_name,
  i.result_value,
  i.result_unit
FROM lab_result_items i
JOIN lab_results r ON i.lab_result_id = r.id
JOIN lab_reports      lr  ON r.lab_report_id      = lr.id
WHERE lr.patient_id      = $1
  AND i.parameter_name = $2
ORDER BY lr.report_date DESC NULLS LAST, lr.created_at DESC
LIMIT $3 OFFSET $4
`

type ListLabItemTimelineByPatientAndParameterParams struct {
	PatientID     pgtype.UUID `json:"patient_id"`
	ParameterName string      `json:"parameter_name"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

type ListLabItemTimelineByPatientAndParameterRow struct {
	ReportID      pgtype.UUID `json:"report_id"`
	LabResultID   pgtype.UUID `json:"lab_result_id"`
	ItemID        pgtype.UUID `json:"item_id"`
	ReportDate    pgtype.Date `json:"report_date"`
	TestName      string      `json:"test_name"`
	ParameterName string      `json:"parameter_name"`
	ResultValue   pgtype.Text `json:"result_value"`
	ResultUnit    pgtype.Text `json:"result_unit"`
}

// ============================================================
// Timeline
// ============================================================
func (q *Queries) ListLabItemTimelineByPatientAndParameter(ctx context.Context, arg ListLabItemTimelineByPatientAndParameterParams) ([]ListLabItemTimelineByPatientAndParameterRow, error) {
	rows, err := q.db.Query(ctx, listLabItemTimelineByPatientAndParameter,
		arg.PatientID,
		arg.ParameterName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLabItemTimelineByPatientAndParameterRow
	for rows.Next() {
		var i ListLabItemTimelineByPatientAndParameterRow
		if err := rows.Scan(
			&i.ReportID,
			&i.LabResultID,
			&i.ItemID,
			&i.ReportDate,
			&i.TestName,
			&i.ParameterName,
			&i.ResultValue,
			&i.ResultUnit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabReportsByPatientID = `-- name: ListLabReportsByPatientID :many

SELECT
    id,
    patient_id,
    patient_name,
    lab_name,
    report_date,
    uploaded_by_user_id,
    fingerprint,
    created_at,
    updated_at
FROM lab_reports
WHERE patient_id = $1
ORDER BY report_date DESC NULLS LAST, created_at DESC
LIMIT $2 OFFSET $3
`

type ListLabReportsByPatientIDParams struct {
	PatientID pgtype.UUID `json:"patient_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type ListLabReportsByPatientIDRow struct {
	ID               pgtype.UUID        `json:"id"`
	PatientID        pgtype.UUID        `json:"patient_id"`
	PatientName      pgtype.Text        `json:"patient_name"`
	LabName          pgtype.Text        `json:"lab_name"`
	ReportDate       pgtype.Date        `json:"report_date"`
	UploadedByUserID pgtype.UUID        `json:"uploaded_by_user_id"`
	Fingerprint      pgtype.Text        `json:"fingerprint"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// ============================================================
// List
// ============================================================
func (q *Queries) ListLabReportsByPatientID(ctx context.Context, arg ListLabReportsByPatientIDParams) ([]ListLabReportsByPatientIDRow, error) {
	rows, err := q.db.Query(ctx, listLabReportsByPatientID, arg.PatientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLabReportsByPatientIDRow
	for rows.Next() {
		var i ListLabReportsByPatientIDRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.PatientName,
			&i.LabName,
			&i.ReportDate,
			&i.UploadedByUserID,
			&i.Fingerprint,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabResultItemsByResultID = `-- name: ListLabResultItemsByResultID :many
SELECT
  id, lab_result_id, parameter_name, result_value, result_unit, reference_text
FROM lab_result_items
WHERE lab_result_id = $1
ORDER BY id
`

func (q *Queries) ListLabResultItemsByResultID(ctx context.Context, labResultID pgtype.UUID) ([]LabResultItem, error) {
	rows, err := q.db.Query(ctx, listLabResultItemsByResultID, labResultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LabResultItem
	for rows.Next() {
		var i LabResultItem
		if err := rows.Scan(
			&i.ID,
			&i.LabResultID,
			&i.ParameterName,
			&i.ResultValue,
			&i.ResultUnit,
			&i.ReferenceText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabResultsByReportID = `-- name: ListLabResultsByReportID :many
SELECT
  id, lab_report_id, test_name, material, method, collected_at, release_at
FROM lab_results
WHERE lab_report_id = $1
ORDER BY collected_at NULLS LAST, id
`

func (q *Queries) ListLabResultsByReportID(ctx context.Context, labReportID pgtype.UUID) ([]LabResult, error) {
	rows, err := q.db.Query(ctx, listLabResultsByReportID, labReportID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LabResult
	for rows.Next() {
		var i LabResult
		if err := rows.Scan(
			&i.ID,
			&i.LabReportID,
			&i.TestName,
			&i.Material,
			&i.Method,
			&i.CollectedAt,
			&i.ReleaseAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
