// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: professional_queries.sql

package professionalsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteProfessionalProfile = `-- name: DeleteProfessionalProfile :execrows
DELETE FROM professional_profiles
WHERE user_id = $1
`

func (q *Queries) DeleteProfessionalProfile(ctx context.Context, userID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProfessionalProfile, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findProfessionalProfileByID = `-- name: FindProfessionalProfileByID :one
SELECT user_id, registration_number, registration_issuer, registration_state, status, verified_at, created_at, updated_at
FROM professional_profiles
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) FindProfessionalProfileByID(ctx context.Context, userID string) (ProfessionalProfile, error) {
	row := q.db.QueryRow(ctx, findProfessionalProfileByID, userID)
	var i ProfessionalProfile
	err := row.Scan(
		&i.UserID,
		&i.RegistrationNumber,
		&i.RegistrationIssuer,
		&i.RegistrationState,
		&i.Status,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findProfessionalProfileByRegistration = `-- name: FindProfessionalProfileByRegistration :one
SELECT user_id, registration_number, registration_issuer, registration_state, status, verified_at, created_at, updated_at
FROM professional_profiles
WHERE registration_number = $1
  AND registration_issuer = $2
LIMIT 1
`

type FindProfessionalProfileByRegistrationParams struct {
	RegistrationNumber string `json:"registration_number"`
	RegistrationIssuer string `json:"registration_issuer"`
}

func (q *Queries) FindProfessionalProfileByRegistration(ctx context.Context, arg FindProfessionalProfileByRegistrationParams) (ProfessionalProfile, error) {
	row := q.db.QueryRow(ctx, findProfessionalProfileByRegistration, arg.RegistrationNumber, arg.RegistrationIssuer)
	var i ProfessionalProfile
	err := row.Scan(
		&i.UserID,
		&i.RegistrationNumber,
		&i.RegistrationIssuer,
		&i.RegistrationState,
		&i.Status,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findProfessionalProfileByUserID = `-- name: FindProfessionalProfileByUserID :one
SELECT user_id, registration_number, registration_issuer, registration_state, status, verified_at, created_at, updated_at
FROM professional_profiles
WHERE user_id = $1
`

func (q *Queries) FindProfessionalProfileByUserID(ctx context.Context, userID string) (ProfessionalProfile, error) {
	row := q.db.QueryRow(ctx, findProfessionalProfileByUserID, userID)
	var i ProfessionalProfile
	err := row.Scan(
		&i.UserID,
		&i.RegistrationNumber,
		&i.RegistrationIssuer,
		&i.RegistrationState,
		&i.Status,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProfessionalProfilesByName = `-- name: ListProfessionalProfilesByName :many
SELECT p.user_id, p.registration_number, p.registration_issuer, p.registration_state, p.status, p.verified_at, p.created_at, p.updated_at
FROM professional_profiles p
JOIN users u ON u.id = p.user_id
WHERE u.full_name ILIKE '%' || $3 || '%'
ORDER BY u.full_name ASC
LIMIT $1
OFFSET $2
`

type ListProfessionalProfilesByNameParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	Name   pgtype.Text `json:"name"`
}

func (q *Queries) ListProfessionalProfilesByName(ctx context.Context, arg ListProfessionalProfilesByNameParams) ([]ProfessionalProfile, error) {
	rows, err := q.db.Query(ctx, listProfessionalProfilesByName, arg.Limit, arg.Offset, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProfessionalProfile
	for rows.Next() {
		var i ProfessionalProfile
		if err := rows.Scan(
			&i.UserID,
			&i.RegistrationNumber,
			&i.RegistrationIssuer,
			&i.RegistrationState,
			&i.Status,
			&i.VerifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProfessionalProfile = `-- name: UpdateProfessionalProfile :one
UPDATE professional_profiles
SET
    registration_number = $2,
    registration_issuer = $3,
    registration_state = $4,
    status = $5,
    verified_at = $6,
    updated_at = now()
WHERE user_id = $1
RETURNING user_id, registration_number, registration_issuer, registration_state, status, verified_at, created_at, updated_at
`

type UpdateProfessionalProfileParams struct {
	UserID             string             `json:"user_id"`
	RegistrationNumber string             `json:"registration_number"`
	RegistrationIssuer string             `json:"registration_issuer"`
	RegistrationState  pgtype.Text        `json:"registration_state"`
	Status             string             `json:"status"`
	VerifiedAt         pgtype.Timestamptz `json:"verified_at"`
}

func (q *Queries) UpdateProfessionalProfile(ctx context.Context, arg UpdateProfessionalProfileParams) (ProfessionalProfile, error) {
	row := q.db.QueryRow(ctx, updateProfessionalProfile,
		arg.UserID,
		arg.RegistrationNumber,
		arg.RegistrationIssuer,
		arg.RegistrationState,
		arg.Status,
		arg.VerifiedAt,
	)
	var i ProfessionalProfile
	err := row.Scan(
		&i.UserID,
		&i.RegistrationNumber,
		&i.RegistrationIssuer,
		&i.RegistrationState,
		&i.Status,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertProfessionalProfile = `-- name: UpsertProfessionalProfile :one

INSERT INTO professional_profiles (
    user_id,
    registration_number,
    registration_issuer,
    registration_state,
    status,
    verified_at
) VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (user_id)
DO UPDATE SET
    registration_number = EXCLUDED.registration_number,
    registration_issuer = EXCLUDED.registration_issuer,
    registration_state = EXCLUDED.registration_state,
    status = EXCLUDED.status,
    verified_at = EXCLUDED.verified_at,
    updated_at = now()
RETURNING user_id, registration_number, registration_issuer, registration_state, status, verified_at, created_at, updated_at
`

type UpsertProfessionalProfileParams struct {
	UserID             string             `json:"user_id"`
	RegistrationNumber string             `json:"registration_number"`
	RegistrationIssuer string             `json:"registration_issuer"`
	RegistrationState  pgtype.Text        `json:"registration_state"`
	Status             string             `json:"status"`
	VerifiedAt         pgtype.Timestamptz `json:"verified_at"`
}

// internal/adapters/outbound/database/sqlc/professional/queries.sql
func (q *Queries) UpsertProfessionalProfile(ctx context.Context, arg UpsertProfessionalProfileParams) (ProfessionalProfile, error) {
	row := q.db.QueryRow(ctx, upsertProfessionalProfile,
		arg.UserID,
		arg.RegistrationNumber,
		arg.RegistrationIssuer,
		arg.RegistrationState,
		arg.Status,
		arg.VerifiedAt,
	)
	var i ProfessionalProfile
	err := row.Scan(
		&i.UserID,
		&i.RegistrationNumber,
		&i.RegistrationIssuer,
		&i.RegistrationState,
		&i.Status,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
